using LucidRAG.Services.Sentinel;

namespace LucidRAG.Services;

/// <summary>
/// Search mode for controlling the retrieval strategy.
/// </summary>
public enum SearchMode
{
    /// <summary>Hybrid search: semantic + keyword boosting (default, best quality)</summary>
    Hybrid,
    /// <summary>Pure semantic/vector search only</summary>
    Semantic,
    /// <summary>Keyword/BM25-style search - boosts exact keyword matches heavily</summary>
    Keyword
}

public interface IAgenticSearchService
{
    Task<SearchResult> SearchAsync(SearchRequest request, CancellationToken ct = default);
    Task<ChatResponse> ChatAsync(ChatRequest request, CancellationToken ct = default);
    IAsyncEnumerable<string> ChatStreamAsync(ChatRequest request, CancellationToken ct = default);
}

public record SearchRequest(
    string Query,
    Guid? CollectionId = null,
    Guid[]? DocumentIds = null,
    int TopK = 10,
    string? SystemPrompt = null,
    ExecutionMode? Mode = null,
    SearchMode SearchMode = SearchMode.Hybrid);

public record SearchResult(
    List<SearchResultItem> Results,
    int TotalResults,
    long ResponseTimeMs)
{
    /// <summary>
    /// The query plan generated by the Sentinel.
    /// Contains decomposed sub-queries and execution details.
    /// </summary>
    public QueryPlan? QueryPlan { get; init; }
};

public record SearchResultItem(
    Guid DocumentId,
    string DocumentName,
    string SegmentId,
    string Text,
    double Score,
    string? SectionTitle = null);

public record ChatRequest(
    string Query,
    Guid? ConversationId = null,
    Guid? CollectionId = null,
    Guid[]? DocumentIds = null,
    string? SystemPrompt = null,
    SearchMode SearchMode = SearchMode.Hybrid,
    string? LensId = null  // Optional lens override (user selection)
);

public record ChatResponse(
    string Answer,
    List<SourceCitation> Sources,
    Guid ConversationId,
    bool AskedForClarification = false,
    string? ClarificationQuestion = null,
    bool IsOffTopic = false,
    DateTimeOffset Timestamp = default)
{
    /// <summary>
    /// The query plan generated by Sentinel showing decomposition.
    /// </summary>
    public QueryPlan? QueryPlan { get; init; }

    /// <summary>
    /// Human-readable decomposition summary for UI display.
    /// </summary>
    public DecompositionInfo? Decomposition { get; init; }

    /// <summary>
    /// The ID of the lens used to format this response.
    /// </summary>
    public string? LensId { get; init; }

    /// <summary>
    /// CSS styles from the active lens (for injection in frontend).
    /// </summary>
    public string? LensStyles { get; init; }
}

/// <summary>
/// Summary of query decomposition for UI display.
/// </summary>
public record DecompositionInfo(
    double Confidence,
    List<SubQueryInfo> SubQueries,
    bool NeedsApproval);

public record SubQueryInfo(
    string Query,
    string Purpose,
    int Priority);

/// <summary>
/// Source citation with full signal transparency.
/// Exposes all retrieval signals so lenses can present WHY each source was selected.
/// CRITICAL: Uses segments/summaries intelligently - NEVER truncates long OCR text!
/// </summary>
public record SourceCitation(
    int Number,
    Guid DocumentId,
    string DocumentName,
    string SegmentId,
    string Text,
    string? PageOrSection = null,
    // Signal scores
    double RrfScore = 0.0,
    double DenseScore = 0.0,
    double Bm25Score = 0.0,
    double SalienceScore = 0.0,
    double FreshnessScore = 0.0,
    // Matching information
    List<string>? MatchedSalientTerms = null,
    List<string>? MatchedEntities = null,
    List<string>? SignalExplanations = null,
    // Metadata
    string? Author = null,
    string? PublishDate = null,
    string? DocumentType = null,
    Dictionary<string, object>? Metadata = null,
    // SUMMARY/SEGMENT HANDLING - Prevent OCR text overload
    string? ExtractiveSummary = null,      // BERT extractive summary
    string? LlmSummary = null,             // LLM-generated summary
    string TextType = "segment",           // segment | summary_extractive | summary_llm | full_text
    int OriginalLength = 0,                // Original text length before summarization
    bool IsOcrSource = false,              // True if from OCR (likely needs summarization)
    int CharacterCount = 0                 // Actual character count of Text field
);
